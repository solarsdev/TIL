# Node Modules

## 노드 관련 사이트

[Index | Node.js v19.4.0 Documentation](https://nodejs.org/dist/latest-v18.x/docs/api/)

[Introduction to Node.js](https://nodejs.dev/en/learn/)

## 콘솔 로그의 진실

### 로그의 심각도에 따른 사용법

- 콘솔 로그에는 여러가지 레벨이 존재
  - log → 개발
  - info → 정보
  - warn → 경보
  - error → 에러, 사용자 에러, 시스템 에러
- 로그를 남길때는 각각의 원인의 심각성에 따라 레벨을 다르게 하여 로그를 남기면 추후에 조사를 할 때 좀 더 편해질 수 있음
- 개발 단계에서는 log를 이용하여 출력할 수도 있지만, 프로덕션 단계에서는 심각도에 따라서 다른 로그를 출력하고 필요한 경우에만 출력하도록 설정할 수도 있음

### assert

- assert는 평가문이 참일 경우에만 실행되어 콘솔에 로그를 남기는 함수
- 특정 상황에만 로그를 남기고 싶은 경우에 사용함 (if문 없이 깔끔하게)

### object 출력

- 오브젝트를 출력하는 방법에는 여러가지가 존재함
  - log (일반적인 출력)
  - table (2차원 테이블 형태로 출력)
  - dir (log와 동일하나 다양한 옵션을 통해 출력을 컨트롤 할 수 있음)
    - showHidden: false
    - colors: true
    - depth: 2

### 성능 확인

- time(index)
- timeEnd(index)

### 카운트

- count → 함수가 몇번 호출되었는지 호출할 수 있음

### 트레이싱

- trace → 함수가 어떤 경로로 호출되어 왔는지 추적

## this란 (브라우저와의 차이점)

- node에서 특정 함수 안의 this는 global을 가리킴
- 클래스 안의 멤버 함수에서는 this가 글로벌을 가리키지 않으며, 해당 클래스를 가리킴
- node에서 글로벌 스코프에서의 this는 브라우저와 다르게 global이 아니고 module.exports임

## 모듈 (export, require)

- 여러개의 파일로 나누어진 JavaScript를 서로간에 불러서 사용하고 싶을 경우에는 Node에서 지원하는 module.exports와 require를 이용하면 상호간에 호출이 가능해짐
- module은 파일(모듈)에 해당하는 정보들을 담고있는 객체로 그중에서 exports는 외부에 노출하고 싶은 변수나 함수에 해당하는 주소값을 제공함
- 외부 파일은 require를 통해 모듈에서 제공하는 exports값을 읽어올수 있고, 그렇게 외부 파일에서 정의된 노출된 함수나 변수에 접근 가능해짐
- JavaScript에서 이러한 기능을 제공하지 않았기 때문에 Node에서 만들어진 기능으로, ES6부터는 자바스크립트 자체에서 모듈을 제공하고 있기 때문에 그것을 사용하는 것이 좋음

## 2015 ES6 모듈 (export, import)

- ES6 부터는 export와 import를 자바스크립트 자체에서 지원하기 시작함
- node에서 사용하기 위해서는 npm을 통해 type을 module로 변경해야 할 필요가 있음 (기존 commonjs)
- 원하는 함수나 변수에서 export를 붙이면 외부 노출되며, 외부 파일에서 import를 통해서 가져올 수 있음

```jsx
// 모든 외부 노출자를 counter라는 객체에 담아서 가져옴
import * as counter from './counter.js';
counter.increase();
counter.getCounter();

// 직접 함수명을 적어서 바로 사용할수 있게 됨
import { increase, getCounter } from './counter.js';
increase();
getCounter();
```

## os (운영체제) 정보

- OS 모듈에서는 다양한 운영체제 관련 정보를 제공

```jsx
const os = require('os');

console.log(os.EOL === '\n');
console.log(os.EOL === '\r\n');

console.log(os.totalmem());
console.log(os.freemem());
console.log(os.type());
console.log(os.userInfo());
console.log(os.cpus());
console.log(os.homedir());
console.log(os.hostname());
```

## process (프로세스) 정보

- node가 실행되고 있는 프로세스 정보를 가져올 수 있음

```jsx
const process = require('process');

console.log(process.execPath);
console.log(process.version);
console.log(process.pid);
console.log(process.ppid);
console.log(process.platform);
console.log(process.env);
console.log(process.uptime());
console.log(process.cwd());
console.log(process.cpuUsage());

// 콜백함수는 콜스택이 모두 종료된 이후에 태스크큐를 수행
setTimeout(() => {
  console.log('setTimeout');
}, 0);

// 태스크큐의 가장 앞에 콜백함수를 설정하기 (setTimeout이 있었지만 그 앞에 설정하기)
process.nextTick(() => {
  console.log('nextTick');
});

for (let i = 0; i < 1000000000; i++) {}
```

## 타이머와 콜스택의 연관성

- 타이머는 기본적으로 콜스택이 모두 수행된 이후에 태스크큐에 콜백함수를 넣어줌
- 따라서 콜스택이 수행될때까지 대기해야 함
- process.nextTick은 태스크큐의 가장 우선순위를 가지기 때문에 콜백함수중 가장 먼저 수행됨

## path 정보

- 운영체제마다 경로를 표현하는 방식이 다른 것을 인식해야 함
  - POSIX: (Mac, Linux) / 구분자
  - Windows: \ 구분자
- os마다 다른 경로를 표현하기 위해 path에서 다양한 선택지를 제공
- 파일 경로는 글로벌에 **filename, **dirname으로 접근할 수 있고, path 모듈의 다양한 함수를 이용해서 표현 가능

## file 동기, 비동기 그리고 프로미스

- fs 모듈은 파일관련 다양한 함수를 제공하고 있음
- 파일관련 함수들은 동기, 비동기, 그리고 프로미스 방식의 3가지로 지원됨
- 동기 방식
  - fs.renameSync와 같이 함수명 뒤에 Sync가 붙는 것이 특징
  - 동기 → 블럭킹이기 때문에 함수의 실행이 콜스택에서 수행됨
  - 동기 함수가 완료될때까지 다른 구문이 수행되지 않고, 에러가 발생시 노드 프로그램이 종료될 수 있음
    - 따라서 동기 함수를 이용하려면 try { } catch() { } 를 사용해야 함
  - 동기 방식은 사용하지 않을 수 있다면 안하는 것이 좋음
- 비동기 방식
  - fs.rename과 같이 일반적인 함수는 비동기로 수행됨
  - 비동기는 수행을 요청하고 바로 다음 구문을 수행하며, 콜스택이 완료된 시점에 콜백 함수를 태스크 큐에 넣어서 이어서 수행할 수 있도록 함
- 프로미스 방식
  - 프로미스는 콜백 함수가 여러개 연결되어 있을 경우에 가독성의 저하 등을 방지하기 위해, 비동기적 수행을 .then .catch 등으로 연결하여 사용할 수 있도록 신택스 슈가를 제공해줌

## 버퍼와 스트림

- 스트림이란 원본 소스를 잘게 나누어 보내는 단위를 이야기 함
- 버퍼는 잘게 나누어진 것들을 하나로 합치는 것
- 어떤 파일을 읽어올 때는 스트림을 이용해서 잘게 쪼개어 가져오고, 버퍼에 담았다가 버퍼 플러시라는 과정을 통해 한번에 출력하게 됨

### 버퍼

- 어떤 정해진 길이의 원시 데이터 (raw-data)
- 버퍼는 원시 데이터이기 때문에 인코딩을 어떤 것으로 하느냐에 따라 다른 형태로 출력 됨
- 버퍼를 직접 만들어서 할당할 수 있고, 다양한 함수를 이용해서 할당, 출력, 변환 가능

### 스트림

- 데이터를 연속적으로 읽어들이거나 쓸때, 이벤트 드리븐으로 중간 중간 청크를 이용해서 처리를 도모할 수 있음
- 버퍼에 모든 데이터를 담으면 메모리 소모가 많아지고, 버퍼의 크기가 최대 처리량이 되어 제약이 생김
- 스트림은 버퍼의 크기를 제한하고 데이터를 연속적으로 처리하기 때문에 효율적임
- 노드에서 제공하는 스트림은 읽기 스트림과 쓰기 스트림이 존재, 각 스트림에는 이벤트가 있어 콜백 함수 구현 가능
- 스트림은 파이프로 연결이 가능하여 다양한 상황에서 데이터를 연계하도록 설계 가능

## 이벤트

- 노드가 이벤트 드리븐인 이유는 특정 상황이 발생했을때 콜백 함수를 부를 수 있는 EventEmitter가 존재하기 때문임
- EventEmitter를 이용하면 다양한 이벤트를 커스텀하게 작성하고 리스너 등록이 가능해짐
